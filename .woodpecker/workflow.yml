when:
  event:
    - push
    - manual

skip_clone: true

steps:
  setup_container:
    image: alpine:latest
    environment:
      WORKSPACE: /var/workspace
      DOCKERHUB_USERNAME:
        from_secret: DOCKERHUB_USERNAME
      DOCKERHUB_TOKEN:
        from_secret: DOCKERHUB_TOKEN
      GIT_USER_NAME:
        from_secret: GIT_USER_NAME
      GIT_USER_EMAIL:
        from_secret: GIT_USER_EMAIL
    commands:
      - apk add --no-cache bash jq curl git docker-cli

      # Git config
      - git config --global user.name "$GIT_USER_NAME"
      - git config --global user.email "$GIT_USER_EMAIL"
      - git config --global --add safe.directory "$WORKSPACE"

      # Clone repo manually into $WORKSPACE
      - git clone --depth=1 https://github.com/Hristo-Nikodimov-Nenkov/micropython-containers.git "$WORKSPACE"
      - cd "$WORKSPACE"
  
      # DockerHub login
      - echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

      # Check services.json
      - |
        SERVICES_JSON="$WORKSPACE/services.json"
        if [ ! -f "$SERVICES_JSON" ]; then
          echo "ERROR: services.json missing at repo root"
          exit 2
        fi      

      - |
        OLDIFS="$IFS"
        IFS=','


        check_required_files() {
            SERVICE_PATH="$1"

            # Check Dockerfile
            if [ ! -f "$SERVICE_PATH/Dockerfile" ]; then
                echo "ERROR: Dockerfile missing in $SERVICE_PATH"
                exit 2
            fi

            # Check build_firmware.sh
            if [ ! -f "$SERVICE_PATH/build_firmware.sh" ]; then
                echo "ERROR: build_firmware.sh missing in $SERVICE_PATH"
                exit 3
            fi

            # Check versions.json
            if [ ! -f "$SERVICE_PATH/versions.json" ]; then
                echo "ERROR: versions.json missing in $SERVICE_PATH"
                exit 4
            fi
        }

        # Check if directory has .service_hash
        check_service_hash() {
            HASH_FILE="$SERVICE_PATH/.service_hash"

            # If .service_hash is missing → full rebuild
            if [ ! -f "$HASH_FILE" ]; then
                FULL_SERVICE_REBUILD=true
                export FULL_SERVICE_REBUILD
                return
            fi

            # Compute combined SHA-256 digest of required files
            CURRENT_HASH=$(cat "$SERVICE_PATH/Dockerfile" \
                                "$SERVICE_PATH/build_firmware.sh" \
                                "$SERVICE_PATH/versions.json" \
                           | sha256sum | awk '{print $1}')

            # Read stored hash
            STORED_HASH=$(cat "$HASH_FILE")

            # Compare hashes
            if [ "$CURRENT_HASH" = "$STORED_HASH" ]; then
                FULL_SERVICE_REBUILD=false
            else
                FULL_SERVICE_REBUILD=true
            fi
            export FULL_SERVICE_REBUILD
        
            echo $FULL_SERVICE_REBUILD
        }

        get_services() {
          # Iterate services
          for dir in $ORDERED_SERVICES; do
              SERVICE_PATH="$WORKSPACE/$dir"

              check_required_files "$SERVICE_PATH" "$dir"
              echo "All required files exist for $dir"

              check_service_hash "$SERVICE_PATH"
          done
        }

        run_build() {
            SERVICE_PATH="$1"
            VERSION_FILE="$SERVICE_PATH/versions.json"

            if ! command -v jq >/dev/null 2>&1; then
                echo "ERROR: jq is required but not installed"
                exit 40
            fi

            # -----------------------------------------------------
            # 1. Synchronous: prepare JSON for each object to build
            # -----------------------------------------------------
            if [ "$FULL_SERVICE_REBUILD" = "true" ]; then
                echo "[INFO] Full rebuild for $SERVICE_PATH"

                JSON_OBJECTS=$(jq -c '.[]' "$VERSION_FILE")
            else
                echo "[INFO] Partial rebuild for $SERVICE_PATH"

                JSON_OBJECTS=$(jq -c '.[] | select(.built == false)' "$VERSION_FILE")
            fi

            # No objects to build
            [ -z "$JSON_OBJECTS" ] && {
                echo "[INFO] Nothing to rebuild in $SERVICE_PATH"
                return
            }

            # -----------------------------------------------------
            # 2. Loop JSON objects and spawn parallel builds
            # -----------------------------------------------------
            echo "$JSON_OBJECTS" | while IFS= read -r OBJ; do

                (
                    # Convert object into flags:
                    # For every key/value pair → produce: --key value
                    FLAGS=$(printf '%s' "$OBJ" | jq -r '
                        to_entries[] |
                        "--" + .key + " " + (.value|tostring)
                    ')

                    echo "[PARALLEL] Running build.sh with flags:"
                    echo "  $FLAGS"

                    # Run build.sh with all flags
                    # Convert flags into proper args
                    set -- $FLAGS

                    sh "$SERVICE_PATH/build.sh" "$SERVICE_PATH" "$@"
                ) &

            done

            # -----------------------------------------------------
            # 3. Wait for all parallel jobs
            # -----------------------------------------------------
            wait
            echo "[INFO] All parallel builds finished for $SERVICE_PATH"
        }
