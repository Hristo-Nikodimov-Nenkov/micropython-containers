when:
  event:
    - push
    - manual

steps:
  - name: Set-up git.
    image: alpine:latest
    environment:
      GIT_USER_NAME:
        from_secret: GIT_USER_NAME
      GIT_USER_EMAIL:
        from_secret: GIT_USER_EMAIL
    commands:
      - cd $CI_WORKSPACE
      - apk add --no-cache git

      - git config user.name "$GIT_USER_NAME" || exit 1
      - git config user.email "$GIT_USER_EMAIL" || exit 2
      - git config --add safe.directory "$CI_WORKSPACE" || exit 3

  - name: Check services.
    image: alpine:latest
    commands:
      - apk add --no-cache jq

      - SERVICES_JSON="$CI_WORKSPACE/services.json"
      - |
        if [[ ! -f "$SERVICES_JSON" ]]; then
          echo "ERROR: services.json missing at repo root ($SERVICES_JSON)" exit 21
        fi

        echo "[INFO] services.json found at $SERVICES_JSON"

      - jq -r 'to_entries | sort_by(.value.order) | .[].key' services.json > services.order

      # Show order (optional, for logs)
      - cat services.order

      # Validate directories exist
      - while read -r service; do [ -d "$CI_WORKSPACE/$service" ] || exit 22; done < services.order

      # Process services in order
      - |
        while read -r service; do
          SERVICE_PATH="$CI_WORKSPACE/$service"

          [ -f "$SERVICE_PATH/Dockerfile" ] || { echo "ERROR: Dockerfile missing in $SERVICE_PATH"; exit 23; }
          [ -f "$SERVICE_PATH/build_firmware.sh" ] || { echo "ERROR: build_firmware.sh missing in $SERVICE_PATH"; exit 24; }
          [ -f "$SERVICE_PATH/versions.json" ] || { echo "ERROR: versions.json missing in $SERVICE_PATH"; exit 25; }

          echo "[INFO] Required files present in $SERVICE_PATH"
        done < services.order

  - name: Build and push containers
    image: docker:latest
    environment:
      DOCKER_CLIENT_TIMEOUT: 300
      DOCKERHUB_USERNAME:
        from_secret: DOCKERHUB_USERNAME
      DOCKERHUB_TOKEN:
        from_secret: DOCKERHUB_TOKEN

    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    commands:
      - apk add --no-cache jq coreutils
      - cd "$CI_WORKSPACE"

      # Docker login
      - echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

      - |
        while read service; do
          SERVICE_PATH="$CI_WORKSPACE/$service"
          HASH_FILE="$SERVICE_PATH/service_hash"

          echo "[INFO] Processing service: $service"

          CURRENT_HASH=$(sha256sum \
            "$SERVICE_PATH/Dockerfile" \
            "$SERVICE_PATH/build_firmware.sh" \
            "$SERVICE_PATH/build.sh" \
            | sha256sum | awk '{print $1}')

          FULL_REBUILD=false
          if [ ! -f "$HASH_FILE" ] || [ "$(cat "$HASH_FILE")" != "$CURRENT_HASH" ]; then
            FULL_REBUILD=true
            echo "[INFO] Full rebuild required for $service"
          fi

          jq -c '.[]' "$SERVICE_PATH/versions.json" | while read obj; do

            version=$(printf '%s\n' "$obj" | jq -r '.micropython')

            FLAGS=""

            for key in $(printf '%s\n' "$obj" | jq -r 'keys[]'); do
              value=$(printf '%s\n' "$obj" | jq -r --arg k "$key" '.[$k] | tostring')
              FLAGS="$FLAGS --$key $value"
            done

            # Remove any built flag coming from JSON
            FLAGS=$(printf '%s\n' "$FLAGS" | sed 's/--built [^ ]*//g')

            # Force built=false on full rebuild
            if [ "$FULL_REBUILD" = "true" ]; then
              FLAGS="$FLAGS --built false"
            fi

            echo "[INFO] Running build.sh for $service, version $version"
            echo "       Flags:$FLAGS"

            if sh "$SERVICE_PATH/build.sh" "$SERVICE_PATH" $FLAGS; then
              BUILD_RESULT=true
              echo "[INFO] Build succeeded for version $version"
            else
              BUILD_RESULT=false
              echo "[WARN] Build failed for version $version (continuing)"
            fi

            tmpfile=$(mktemp)
            jq --argjson built "$BUILD_RESULT" --arg micropython "$version" \
              'map(if .micropython == $micropython then .built = $built else . end)' \
              "$SERVICE_PATH/versions.json" > "$tmpfile" &&
              mv "$tmpfile" "$SERVICE_PATH/versions.json"

          done

          echo "$CURRENT_HASH" > "$HASH_FILE"
          echo "[INFO] Finished service: $service"

        done < services.order
