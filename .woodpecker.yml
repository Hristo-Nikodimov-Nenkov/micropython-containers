when:
  event:
    - push
    - manual

steps:
  - name: Set-up git.
    image: alpine:latest
    environment:
      GIT_USER_NAME:
        from_secret: GIT_USER_NAME
      GIT_USER_EMAIL:
        from_secret: GIT_USER_EMAIL
    commands:
      - cd $CI_WORKSPACE
      - apk add --no-cache git

      - git config user.name "$GIT_USER_NAME" || exit 1
      - git config user.email "$GIT_USER_EMAIL" || exit 2
      - git config --add safe.directory "$CI_WORKSPACE" || exit 3

  - name: Check services.
    image: alpine:latest
    commands:
      - apk add --no-cache jq

      - SERVICES_JSON="$CI_WORKSPACE/services.json"
      - |
        if [[ ! -f "$SERVICES_JSON" ]]; then
          echo "ERROR: services.json missing at repo root ($SERVICES_JSON)"; exit 21
        fi

        echo "[INFO] services.json found at $SERVICES_JSON"

      - jq -r 'to_entries | sort_by(.value.order) | .[].key' services.json > services.order

      # Show order (optional, for logs)
      - cat services.order

      # Validate directories exist
      - while read -r service; do [ -d "$CI_WORKSPACE/$service" ] || exit 22; done < services.order

      # Process services in order
      - |
        while read -r service; do
          SERVICE_PATH="$CI_WORKSPACE/$service"

          [ -f "$SERVICE_PATH/Dockerfile" ] || { echo "ERROR: Dockerfile missing in $SERVICE_PATH"; exit 23; }
          [ -f "$SERVICE_PATH/build_firmware.sh" ] || { echo "ERROR: build_firmware.sh missing in $SERVICE_PATH"; exit 24; }
          [ -f "$SERVICE_PATH/versions.json" ] || { echo "ERROR: versions.json missing in $SERVICE_PATH"; exit 25; }

          echo "[INFO] All required files present in $service directory."
        done < services.order
  
  - name: Build and push containers
    image: docker:latest
    shell: bash
    environment:
      DOCKERHUB_USERNAME:
        from_secret: DOCKERHUB_USERNAME
      DOCKERHUB_TOKEN:
        from_secret: DOCKERHUB_TOKEN
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    commands:
      - apk add --no-cache bash jq coreutils
      - cd "$CI_WORKSPACE"

      # Docker login
      - echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

      - |
        while read -r service; do
          SERVICE_PATH="$CI_WORKSPACE/$service"
          HASH_FILE="$SERVICE_PATH/service_hash"
          echo "[INFO] Processing service: $service"

          CURRENT_HASH=$(sha256sum "$SERVICE_PATH/Dockerfile" "$SERVICE_PATH/build_firmware.sh" "$SERVICE_PATH/build.sh" | sha256sum | awk '{print $1}')
          FULL_REBUILD="false"
          if [ ! -f "$HASH_FILE" ] || [ "$(cat "$HASH_FILE")" != "$CURRENT_HASH" ]; then
            FULL_REBUILD="true"
            echo "[INFO] Full rebuild required for $service"
          fi

          # Read versions.json
          jq -c '.[]' "$SERVICE_PATH/versions.json" | while read -r obj; do
            FLAGS=()
            for key in $(jq -r 'keys[]' <<<"$obj"); do
              value=$(jq -r --arg k "$key" '.[$k]' <<<"$obj")
              FLAGS+=("--$key" "$value")
            done

            if [ "$FULL_REBUILD" = "true" ]; then
              FLAGS+=("--built" "false")
            fi

            version=$(jq -r '.micropython' <<<"$obj")
            echo "[INFO] Running build.sh for $service, version $version"
            printf '  %q\n' "${FLAGS[@]}"

            if bash "$SERVICE_PATH/build.sh" "$SERVICE_PATH" "${FLAGS[@]}"; then
              BUILD_RESULT=true
              echo "[INFO] Build succeeded for version $version"
            else
              BUILD_RESULT=false
              echo "[WARN] Build failed for version $version (continuing)"
            fi

            tmpfile=$(mktemp)
            jq --argjson built "$BUILD_RESULT" --arg micropython "$version" \
              'map(if .micropython==$micropython then .built=$built else . end)' \
              "$SERVICE_PATH/versions.json" > "$tmpfile" && mv "$tmpfile" "$SERVICE_PATH/versions.json"
          done

          echo "$CURRENT_HASH" > "$HASH_FILE"
          echo "[INFO] Finished service: $service"
        done < services.order
