when:
  event:
    - push
    - manual

steps:
  - name: Set-up git.
    image: alpine:latest
    environment:
      GIT_USER_NAME:
        from_secret: GIT_USER_NAME
      GIT_USER_EMAIL:
        from_secret: GIT_USER_EMAIL
    commands:
      - cd $CI_WORKSPACE
      - apk add --no-cache git

      - git config user.name "$GIT_USER_NAME" || exit 1
      - git config user.email "$GIT_USER_EMAIL" || exit 2
      - git config --add safe.directory "$CI_WORKSPACE" || exit 3

  - name: Check services.
    image: alpine:latest
    commands:
      - apk add --no-cache jq

      - SERVICES_JSON="$CI_WORKSPACE/services.json"
      - |
        if [[ ! -f "$SERVICES_JSON" ]]; then
          echo "ERROR: services.json missing at repo root ($SERVICES_JSON)" exit 21
        fi

        echo "[INFO] services.json found at $SERVICES_JSON"

      - jq -r 'to_entries | sort_by(.value.order) | .[].key' services.json > services.order

      # Show order (optional, for logs)
      - cat services.order

      # Validate directories exist
      - while read -r service; do [ -d "$CI_WORKSPACE/$service" ] || exit 22; done < services.order

      # Process services in order
      - |
        while read -r service; do
          SERVICE_PATH="$CI_WORKSPACE/$service"

          [ -f "$SERVICE_PATH/Dockerfile" ] || { echo "ERROR: Dockerfile missing in $SERVICE_PATH"; exit 23; }
          [ -f "$SERVICE_PATH/build_firmware.sh" ] || { echo "ERROR: build_firmware.sh missing in $SERVICE_PATH"; exit 24; }
          [ -f "$SERVICE_PATH/versions.json" ] || { echo "ERROR: versions.json missing in $SERVICE_PATH"; exit 25; }

          echo "[INFO] Required files present in $SERVICE_PATH"
        done < services.order

  - name: Build and push containers
    image: docker:latest
    environment:
      DOCKER_CLIENT_TIMEOUT: 1200
      DOCKERHUB_USERNAME:
        from_secret: DOCKERHUB_USERNAME
      DOCKERHUB_TOKEN:
        from_secret: DOCKERHUB_TOKEN

    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    commands:
      - apk add --no-cache jq coreutils
      - cd "$CI_WORKSPACE"

      # Docker login
      - echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

      - |
        while read service; do
          SERVICE_PATH="$CI_WORKSPACE/$service"
          HASH_FILE="$SERVICE_PATH/service_hash"

          echo "[INFO] Processing service: $service"

          CURRENT_HASH=$(sha256sum \
            "$SERVICE_PATH/Dockerfile" \
            "$SERVICE_PATH/build_firmware.sh" \
            "$SERVICE_PATH/build.sh" \
            | sha256sum | awk '{print $1}')

          FULL_REBUILD=false
          if [ ! -f "$HASH_FILE" ] || [ "$(cat "$HASH_FILE")" != "$CURRENT_HASH" ]; then
            FULL_REBUILD=true
            echo "[INFO] Full rebuild required for $service"
          fi

          jq -c '.[]' "$SERVICE_PATH/versions.json" | while read obj; do

            version=$(printf '%s\n' "$obj" | jq -r '.micropython')

            FLAGS=""

            for key in $(printf '%s\n' "$obj" | jq -r 'keys[]'); do
              value=$(printf '%s\n' "$obj" | jq -r --arg k "$key" '.[$k] | tostring')
              FLAGS="$FLAGS --$key $value"
            done

            # Remove any built flag coming from JSON
            FLAGS=$(printf '%s\n' "$FLAGS" | sed 's/--built [^ ]*//g')

            # Force built=false on full rebuild
            if [ "$FULL_REBUILD" = "true" ]; then
              FLAGS="$FLAGS --built false"
            fi

            echo "[INFO] Running build.sh for $service, version $version"
            echo "       Flags:$FLAGS"

            if sh "$SERVICE_PATH/build.sh" "$SERVICE_PATH" $FLAGS; then
              BUILD_RESULT=true
              echo "[INFO] Build succeeded for version $version"
            else
              BUILD_RESULT=false
              echo "[WARN] Build failed for version $version (continuing)"
            fi

            tmpfile=$(mktemp)
            jq --argjson built "$BUILD_RESULT" --arg micropython "$version" \
              'map(if .micropython == $micropython then .built = $built else . end)' \
              "$SERVICE_PATH/versions.json" > "$tmpfile" &&
              mv "$tmpfile" "$SERVICE_PATH/versions.json"

          done

          echo "$CURRENT_HASH" > "$HASH_FILE"
          echo "[INFO] Finished service: $service"

        done < services.order
  
  - name: Update DockerHub documentation.
    image: docker:latest
    environment:
      DOCKERHUB_USERNAME:
        from_secret: DOCKERHUB_USERNAME
      DOCKERHUB_TOKEN:
        from_secret: DOCKERHUB_TOKEN
    commands:
      - apk add --no-cache curl jq coreutils
      - cd "$CI_WORKSPACE"

      - |
        echo "[INFO] Authenticating to Docker Hub API"
        TOKEN=$(curl -s -X POST https://hub.docker.com/v2/users/login/ \
          -H "Content-Type: application/json" \
          -d "{\"username\": \"$DOCKERHUB_USERNAME\", \"password\": \"$DOCKERHUB_TOKEN\"}" \
          | jq -r .token)

        if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
          echo "ERROR: Failed to authenticate to Docker Hub"
          exit 1
        fi

        while read service; do
          SERVICE_PATH="$CI_WORKSPACE/$service"
          README="$SERVICE_PATH/README.md"
          HASH_FILE="$SERVICE_PATH/readme_hash"
          REPO="$DOCKERHUB_USERNAME/$service"

          if [ ! -f "$README" ]; then
            echo "[INFO] No README.md for $service — skipping"
            continue
          fi

          CURRENT_HASH=$(sha256sum "$README" | awk '{print $1}')

          if [ -f "$HASH_FILE" ]; then
            SAVED_HASH=$(cat "$HASH_FILE")
            if [ "$CURRENT_HASH" = "$SAVED_HASH" ]; then
              echo "[INFO] README unchanged for $service — skipping"
              continue
            fi
          fi

          echo "[INFO] Uploading README for $service"

          README_CONTENT=$(jq -Rs . < "$README")

          curl -s -X PATCH \
            "https://hub.docker.com/v2/repositories/$REPO/" \
            -H "Authorization: JWT $TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"full_description\": $README_CONTENT}" \
            > /dev/null

          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to update README for $service"
            continue
          fi

          echo "$CURRENT_HASH" > "$HASH_FILE"
          echo "[INFO] README updated for $service"

        done < services.order
